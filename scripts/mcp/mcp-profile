#!/bin/bash

# MCP Profile Switcher for Claude Code & Gemini CLI
# Part of 002-mcp-manager project
# Usage: mcp-profile [dev|ui|full|status|list|backup] [--tool=claude|gemini|all]

# --- Configuration and Global Variables ---

# Configuration paths for Claude Code
CLAUDE_CONFIG="$HOME/.claude.json" # Main configuration file
CLAUDE_PROFILES_DIR="$HOME/.config/claude-code/profiles" # Directory for profile definitions
CLAUDE_BACKUP_DIR="$HOME/.config/claude-code/backups" # Directory for automatic backups

# Configuration paths for Gemini CLI
# Prefer XDG-compliant location, fallback to legacy
if [ -f "$HOME/.config/gemini/settings.json" ]; then
    GEMINI_CONFIG="$HOME/.config/gemini/settings.json"
elif [ -f "$HOME/.gemini/settings.json" ]; then
    GEMINI_CONFIG="$HOME/.gemini/settings.json"
else
    # Default to XDG location (will be created)
    GEMINI_CONFIG="$HOME/.config/gemini/settings.json"
fi
GEMINI_BACKUP_DIR="$HOME/.config/gemini/backups" # Directory for automatic backups

# Shared profiles directory (tool-agnostic)
PROFILES_DIR="$HOME/.config/mcp-profiles"

# Backward compatibility: if old Claude-specific profiles exist, use them
if [ -d "$CLAUDE_PROFILES_DIR" ] && [ ! -d "$PROFILES_DIR" ]; then
    PROFILES_DIR="$CLAUDE_PROFILES_DIR"
fi

# Default tool to manage (can be: claude, gemini, all). Can be overridden by the --tool flag or MCP_TOOL environment variable.
TOOL_TARGET="${MCP_TOOL:-all}"
# Copilot MCP support flag (stub)
COPILOT_SUPPORTED="false"

# Create necessary directories if they don't exist to prevent errors.
mkdir -p "$PROFILES_DIR" "$CLAUDE_BACKUP_DIR" "$GEMINI_BACKUP_DIR"
mkdir -p "$(dirname "$GEMINI_CONFIG")"

# Colors for styled output in the terminal.
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Profile definitions. Each profile has a name, a description, and an estimated token count.
declare -A PROFILES
PROFILES[github]="GitHub only|~3K"
PROFILES[hf]="HuggingFace only|~73K"
PROFILES[dev]="Minimal development|~7K"
PROFILES[ui]="UI/Design work|~12K"
PROFILES[full]="All servers|~12K"

# Flags to track the availability of supported tools.
HAS_CLAUDE=false
HAS_GEMINI=false
HAS_GH=false

# --- Functions ---

# Function: detect_tools
# Purpose: Detects which of the supported CLI tools are installed and available in the PATH.
detect_tools() {
    command -v claude &>/dev/null && HAS_CLAUDE=true
    command -v gemini &>/dev/null && HAS_GEMINI=true
    command -v gh &>/dev/null && HAS_GH=true
}

# Function: get_project_path
# Purpose: Determines the root path of the current project.
#          If inside a Git repository, it returns the repository root. Otherwise, it returns the current working directory.
# Returns: The absolute path to the project root.
get_project_path() {
    if git rev-parse --show-toplevel &>/dev/null; then
        git rev-parse --show-toplevel
    else
        pwd
    fi
}

# Function: parse_tool_arg
# Purpose: Parses command-line arguments to determine which tool to manage (claude, gemini, or all).
# Arguments: The command-line arguments passed to the script.
parse_tool_arg() {
    for arg in "$@"; do
        case "$arg" in
            --tool=claude)
                if ! $HAS_CLAUDE; then
                    echo -e "${YELLOW}Warning: --tool=claude specified, but claude CLI not found.${NC}"
                    TOOL_TARGET="none"
                else
                    TOOL_TARGET="claude"
                fi
                ;;
            --tool=gemini)
                if ! $HAS_GEMINI; then
                    echo -e "${YELLOW}Warning: --tool=gemini specified, but gemini CLI not found.${NC}"
                    TOOL_TARGET="none"
                else
                    TOOL_TARGET="gemini"
                fi
                ;;
            --tool=copilot)
                echo -e "${YELLOW}Warning: Copilot CLI MCP support is not yet implemented.${NC}"
                TOOL_TARGET="copilot"
                ;;
            --tool=all)
                TOOL_TARGET="all"
                ;;
        esac
    done
}


# Function: check_dependencies
# Purpose: Checks for required dependencies like jq and the configuration files for the selected tools.
#          Exits with an error if critical dependencies are missing.
check_dependencies() {
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed${NC}"
        echo "Install with: sudo apt install jq"
        exit 1
    fi

    # Check for Claude Code
    if [ "$TOOL_TARGET" = "claude" ] || [ "$TOOL_TARGET" = "all" ]; then
        if [ ! -f "$CLAUDE_CONFIG" ]; then
            if [ "$TOOL_TARGET" = "claude" ]; then
                echo -e "${RED}Error: Claude Code config not found at $CLAUDE_CONFIG${NC}"
                echo "Have you run Claude Code at least once?"
                exit 1
            else
                echo -e "${YELLOW}Warning: Claude Code config not found at $CLAUDE_CONFIG${NC}"
                echo "Skipping Claude Code configuration..."
                TOOL_TARGET="gemini"  # Fallback to gemini only
            fi
        fi
    fi

    # Check for Gemini CLI
    if [ "$TOOL_TARGET" = "gemini" ] || [ "$TOOL_TARGET" = "all" ]; then
        if ! command -v gemini &> /dev/null; then
            if [ "$TOOL_TARGET" = "gemini" ]; then
                echo -e "${RED}Error: Gemini CLI not found${NC}"
                echo "Install Gemini CLI first"
                exit 1
            else
                echo -e "${YELLOW}Warning: Gemini CLI not installed${NC}"
                echo "Skipping Gemini CLI configuration..."
                TOOL_TARGET="claude"  # Fallback to claude only
            fi
        fi

        # Initialize Gemini config if it doesn't exist
        if [ ! -f "$GEMINI_CONFIG" ]; then
            echo '{"mcpServers":{}}' > "$GEMINI_CONFIG"
            echo -e "${GREEN}✓ Created Gemini config at $GEMINI_CONFIG${NC}"
        fi
    fi
}

# Function: get_servers_from_profile
# Purpose: Reads a profile's JSON file and returns a comma-separated list of its server names.
# Arguments:
#   $1 - profile_name: The name of the profile (e.g., "dev").
# Returns: A comma-separated string of server names.
get_servers_from_profile() {
    local profile=$1
    local profile_file="$PROFILES_DIR/$profile.json"

    if [ -f "$profile_file" ]; then
        jq -r 'keys | join(", ")' "$profile_file" 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

# Function: get_active_servers_claude
# Purpose: Gets the currently active MCP servers for the current project from the Claude Code configuration.
# Returns: A comma-separated string of active server names.
get_active_servers_claude() {
    local project_path=$(get_project_path)

    if jq -e --arg path "$project_path" '.projects[$path].mcpServers' "$CLAUDE_CONFIG" &>/dev/null; then
        jq -r --arg path "$project_path" '.projects[$path].mcpServers | keys | join(", ")' "$CLAUDE_CONFIG" 2>/dev/null || echo "none"
    else
        echo "none"
    fi
}

# Function: get_active_servers_gemini
# Purpose: Gets the currently active MCP servers from the Gemini CLI configuration.
# Returns: A comma-separated string of active server names.
get_active_servers_gemini() {
    if [ -f "$GEMINI_CONFIG" ]; then
        jq -r '.mcpServers | keys | join(", ")' "$GEMINI_CONFIG" 2>/dev/null || echo "none"
    else
        echo "none"
    fi
}

# Function: get_active_servers
# Purpose: A unified function that gets the active servers based on the current TOOL_TARGET.
# Returns: A comma-separated string of active server names.
get_active_servers() {
    if [ "$TOOL_TARGET" = "gemini" ]; then
        get_active_servers_gemini
    else
        get_active_servers_claude
    fi
}

# Function: count_active_servers
# Purpose: Counts the number of currently active MCP servers for the current project.
# Returns: The number of active servers.
count_active_servers() {
    local project_path=$(get_project_path)

    jq --arg path "$project_path" '(.projects[$path].mcpServers // {}) | length' "$CLAUDE_CONFIG" 2>/dev/null || echo "0"
}

# Function: identify_active_profile
# Purpose: Compares the current server configuration against the known profiles to identify which one is active.
# Returns: The name of the active profile (e.g., "dev") or "CUSTOM" if it doesn't match any known profile.
identify_active_profile() {
    local project_path=$(get_project_path)

    # Get current servers config from Claude config
    local current_servers=$(jq --arg path "$project_path" '.projects[$path].mcpServers // {}' "$CLAUDE_CONFIG" 2>/dev/null)

    # Compare with each profile
    for profile in github hf dev ui full; do
        local profile_file="$PROFILES_DIR/$profile.json"
        if [ -f "$profile_file" ]; then
            local profile_servers=$(cat "$profile_file")

            # Compare JSON objects (ignore whitespace/formatting)
            if [ "$(echo "$current_servers" | jq -S .)" = "$(echo "$profile_servers" | jq -S .)" ]; then
                echo "$profile"
                return
            fi
        fi
    done

    echo "CUSTOM"
}

# Function: create_backup
# Purpose: Creates a timestamped backup of a configuration file.
# Arguments:
#   $1 - tool_name: The name of the tool (e.g., "Claude Code").
#   $2 - config_path: The path to the configuration file to back up.
#   $3 - backup_dir: The directory where the backup file should be saved.
create_backup() {
    local tool_name=$1
    local config_path=$2
    local backup_dir=$3
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$backup_dir/${tool_name,,}-backup-$timestamp.json"

    if [ -f "$config_path" ]; then
        cp "$config_path" "$backup_file"
        echo -e "${BLUE}✓ Backed up $tool_name config${NC}"
        echo "  → $backup_file"
    fi
}

# Function: show_status
# Purpose: Displays the current MCP profile status, including the active profile, servers, and token usage.
show_status() {

    check_dependencies

    local project_path=$(get_project_path)
    local active_profile=$(identify_active_profile)
    local server_count=$(count_active_servers)
    local servers=$(get_active_servers)

    echo -e "${BLUE}=== MCP Profile Status ===${NC}"
    echo ""
    echo -e "Project: ${CYAN}$project_path${NC}"
    if [ "$TOOL_TARGET" = "copilot" ] || [ "$TOOL_TARGET" = "all" ]; then
        echo -e "Copilot MCP: ${YELLOW}unsupported${NC}"
    fi
    echo ""

    if [ "$active_profile" != "CUSTOM" ]; then
        IFS='|' read -r desc tokens <<< "${PROFILES[$active_profile]}"

        # Color based on token usage
        if [[ "$tokens" == "~3K" ]] || [[ "$tokens" == "~7K" ]]; then
            TOKEN_COLOR=$GREEN
        elif [[ "$tokens" == "~12K" ]]; then
            TOKEN_COLOR=$YELLOW
        else
            TOKEN_COLOR=$RED
        fi

        echo -e "Active Profile: ${CYAN}${active_profile^^}${NC}"
        echo -e "Description: $desc"
        echo -e "Servers ($server_count): $servers"
        echo -e "Context Usage: ${TOKEN_COLOR}$tokens tokens${NC}"
    else
        echo -e "Active Profile: ${YELLOW}CUSTOM${NC}"
        echo -e "Description: Custom configuration"
        echo -e "Servers ($server_count): $servers"
    fi

    echo ""
    list_profiles
}

# Function: list_profiles
# Purpose: Lists all available profiles with their descriptions, token estimates, and associated servers.
list_profiles() {
    echo -e "${BLUE}Available Profiles:${NC}"
    for profile in github hf dev ui full; do
        IFS='|' read -r desc tokens <<< "${PROFILES[$profile]}"
        servers=$(get_servers_from_profile "$profile")
        printf "  %-6s - %s - %s\n" "$profile" "$desc" "$tokens"
        printf "           Servers: %s\n" "$servers"
    done
    echo ""
    echo "Usage: mcp-profile [github|hf|dev|ui|full|status|list|test|backup]"
}

# Function: switch_profile
# Purpose: Switches the MCP server configuration to the selected profile for the targeted tools.
# Arguments:
#   $1 - profile_name: The name of the profile to switch to.
switch_profile() {
    check_dependencies

    local PROFILE=$1
    local PROFILE_FILE="$PROFILES_DIR/$PROFILE.json"
    local project_path=$(get_project_path)
    local TIMESTAMP=$(date +%Y%m%d_%H%M%S)

    if [ ! -f "$PROFILE_FILE" ]; then
        echo -e "${RED}Error: Profile '$PROFILE' not found${NC}"
        echo "Looking for: $PROFILE_FILE"
        echo ""
        list_profiles
        exit 1
    fi

    # Read profile servers
    local new_servers=$(cat "$PROFILE_FILE")
    # Validate profile JSON (must be an object)
    if ! jq -e 'type=="object"' "$PROFILE_FILE" >/dev/null 2>&1; then
        echo -e "${RED}Error: Invalid profile JSON (must be an object): $PROFILE_FILE${NC}"
        exit 1
    fi

    # Update Claude Code if enabled
    if ([ "$TOOL_TARGET" = "claude" ] || [ "$TOOL_TARGET" = "all" ]) && $HAS_CLAUDE; then
        if [ -f "$CLAUDE_CONFIG" ]; then
            create_backup "Claude Code" "$CLAUDE_CONFIG" "$CLAUDE_BACKUP_DIR"

            # Update Claude config with new servers for current project
            jq --arg path "$project_path" \
               --argjson servers "$new_servers" \
               '.projects[$path].mcpServers = $servers' \
               "$CLAUDE_CONFIG" > "$CLAUDE_CONFIG.tmp" && mv "$CLAUDE_CONFIG.tmp" "$CLAUDE_CONFIG"

            echo -e "${GREEN}✓ Switched Claude Code to '$PROFILE' profile${NC}"
            echo -e "${YELLOW}  ⚠ Restart Claude Code for changes to take effect${NC}"
        fi
    fi

    # Update Gemini CLI if enabled
    if ([ "$TOOL_TARGET" = "gemini" ] || [ "$TOOL_TARGET" = "all" ]) && $HAS_GEMINI; then
        if [ -f "$GEMINI_CONFIG" ]; then
            create_backup "Gemini CLI" "$GEMINI_CONFIG" "$GEMINI_BACKUP_DIR"

            # Update Gemini config with new servers (global, not project-specific)
            jq --argjson servers "$new_servers" \
               '.mcpServers = $servers' \
               "$GEMINI_CONFIG" > "$GEMINI_CONFIG.tmp" && mv "$GEMINI_CONFIG.tmp" "$GEMINI_CONFIG"

            echo -e "${GREEN}✓ Switched Gemini CLI to '$PROFILE' profile${NC}"
            echo -e "${YELLOW}  ⚠ Restart Gemini CLI for changes to take effect${NC}"
        fi
    fi

    echo ""
    echo -e "${GREEN}✓ Profile switch complete${NC}"
    echo ""

    # Show new status
    show_status
}

# Function: show_backups
# Purpose: Displays a list of recent configuration backups for the targeted tools.
show_backups() {
    echo -e "${BLUE}=== Recent Backups ===${NC}"
    echo ""

    local has_backups=0

    # Show Claude Code backups
    if [ "$TOOL_TARGET" = "claude" ] || [ "$TOOL_TARGET" = "all" ]; then
        if [ -d "$CLAUDE_BACKUP_DIR" ] && [ -n "$(ls -A "$CLAUDE_BACKUP_DIR" 2>/dev/null)" ]; then
            echo -e "${CYAN}Claude Code:${NC}"
            ls -lht "$CLAUDE_BACKUP_DIR"/*.json 2>/dev/null | head -5 | while read -r line; do
                echo "  $line"
            done
            echo "  Directory: $CLAUDE_BACKUP_DIR"
            echo ""
            has_backups=1
        fi
    fi

    # Show Gemini CLI backups
    if [ "$TOOL_TARGET" = "gemini" ] || [ "$TOOL_TARGET" = "all" ]; then
        if [ -d "$GEMINI_BACKUP_DIR" ] && [ -n "$(ls -A "$GEMINI_BACKUP_DIR" 2>/dev/null)" ]; then
            echo -e "${CYAN}Gemini CLI:${NC}"
            ls -lht "$GEMINI_BACKUP_DIR"/*.json 2>/dev/null | head -5 | while read -r line; do
                echo "  $line"
            done
            echo "  Directory: $GEMINI_BACKUP_DIR"
            echo ""
            has_backups=1
        fi
    fi

    if [ $has_backups -eq 0 ]; then
        echo -e "${YELLOW}No backups found${NC}"
    fi
}

# Function: test_github_cli
# Purpose: Tests the authentication status of the GitHub CLI (`gh`).
test_github_cli() {
    echo -e "${CYAN}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│${NC}$(center_text_in_box "${BLUE}GitHub CLI Authentication${NC}" 83)${CYAN}│${NC}"
    echo -e "${CYAN}└───────────────────────────────────────────────────────────────────────────────────┘${NC}"

    # Check if gh CLI is installed
    if ! command -v gh &> /dev/null; then
        echo -e "  ${RED}✗ gh CLI not installed${NC}"
        echo ""
        return 1
    fi

    # Run gh auth status and capture output
    local auth_output=$(gh auth status 2>&1)
    local auth_exit=$?

    if [ $auth_exit -eq 0 ]; then
        echo -e "  ${GREEN}✓ Authentication successful${NC}"
        echo ""
        # Show actual output from gh auth status
        echo "$auth_output" | grep -E "(Logged in|Account|Token|Token scopes)" | sed 's/^/    /'
        echo ""

        # Get rate limit info
        local rate_info=$(gh api rate_limit --jq '.resources.core | "Limit: \(.limit)/hour | Used: \(.used) | Remaining: \(.remaining)"' 2>/dev/null)
        if [ $? -eq 0 ]; then
            echo -e "    ${CYAN}Rate limit:${NC} $rate_info"
        fi
    else
        echo -e "  ${RED}✗ Authentication failed${NC}"
        echo "$auth_output" | sed 's/^/    /'
    fi
    echo ""
}

# Function: test_github_mcp_server
# Purpose: Tests the configuration and connectivity of the GitHub MCP server.
test_github_mcp_server() {
    echo -e "${CYAN}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│${NC}$(center_text_in_box "${BLUE}GitHub MCP Server${NC}" 83)${CYAN}│${NC}"
    echo -e "${CYAN}└───────────────────────────────────────────────────────────────────────────────────┘${NC}"

    # Check if github is in active servers
    local project_path=$(get_project_path)
    local active_servers=$(get_active_servers)

    if ! echo "$active_servers" | grep -q "github"; then
        echo -e "  ${YELLOW}⚠ github MCP server not in active profile${NC}"
        echo ""
        return
    fi

    # Check MCP server configuration
    local mcp_command=$(jq -r --arg path "$project_path" '.projects[$path].mcpServers["github"].command // empty' "$CLAUDE_CONFIG" 2>/dev/null)

    if [ -z "$mcp_command" ]; then
        echo -e "  ${RED}✗ GitHub MCP server not configured${NC}"
        echo ""
        return 1
    fi

    echo -e "  ${CYAN}Command:${NC} $mcp_command"

    # Check if the MCP command/wrapper exists
    if [ ! -x "$mcp_command" ]; then
        echo -e "  ${RED}✗ MCP server command not executable${NC}"
        echo -e "    Path: $mcp_command"
        echo ""
        return 1
    fi

    # Try to verify MCP server is listed and healthy
    if command -v claude &>/dev/null; then
        local mcp_status=$(claude mcp list 2>/dev/null | grep "github")

        if echo "$mcp_status" | grep -q "✓"; then
            echo -e "  ${GREEN}✓ Server active and connected${NC}"
            echo -e "    ${CYAN}Status:${NC} Connected via Claude Code"
        elif echo "$mcp_status" | grep -q "github"; then
            echo -e "  ${YELLOW}⚠ Server configured but connection unclear${NC}"
            echo -e "    Try: /mcp command in Claude Code to reconnect"
        else
            echo -e "  ${YELLOW}⚠ Cannot verify server status${NC}"
            echo -e "    Run 'claude mcp list' to check server health"
        fi
    else
        # Fallback: just verify the command exists
        echo -e "  ${GREEN}✓ Server configured${NC}"
        echo -e "    Command exists and is executable"
        echo -e "    ${YELLOW}Note: claude CLI not available for full verification${NC}"
    fi
    echo ""
}

# Function: test_huggingface_mcp_oauth
# Purpose: Tests the OAuth-based authentication for the HuggingFace MCP server.
test_huggingface_mcp_oauth() {
    echo -e "${CYAN}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│${NC}$(center_text_in_box "${BLUE}HuggingFace MCP Server (OAuth)${NC}" 83)${CYAN}│${NC}"
    echo -e "${CYAN}└───────────────────────────────────────────────────────────────────────────────────┘${NC}"

    # Check if hf-mcp-server is in active servers
    local project_path=$(get_project_path)
    local active_servers=$(get_active_servers)

    if ! echo "$active_servers" | grep -q "hf-mcp-server"; then
        echo -e "  ${YELLOW}⚠ hf-mcp-server not in active profile${NC}"
        echo -e "    Switch to 'full' profile to enable HuggingFace MCP"
        echo ""
        return
    fi

    # Check MCP server configuration
    local mcp_url=$(jq -r --arg path "$project_path" '.projects[$path].mcpServers["hf-mcp-server"].url // empty' "$CLAUDE_CONFIG" 2>/dev/null)

    if [ -z "$mcp_url" ]; then
        echo -e "  ${RED}✗ HuggingFace MCP server not configured${NC}"
        echo ""
        return 1
    fi

    echo -e "  ${CYAN}MCP URL:${NC} $mcp_url"

    # Test OAuth connection using Claude Code's built-in MCP connection
    # Since we can't directly test the OAuth session from bash, we check if Claude can connect
    if command -v claude &>/dev/null; then
        # Try to verify MCP server is listed and healthy
        local mcp_status=$(claude mcp list 2>/dev/null | grep "hf-mcp-server")

        if echo "$mcp_status" | grep -q "✓ Connected"; then
            echo -e "  ${GREEN}✓ OAuth session active${NC}"
            echo -e "    ${CYAN}Status:${NC} Connected via Claude Code"
        elif echo "$mcp_status" | grep -q "hf-mcp-server"; then
            echo -e "  ${YELLOW}⚠ Server configured but connection unclear${NC}"
            echo -e "    Try: /mcp command in Claude Code to reconnect"
        else
            echo -e "  ${RED}✗ Server not responding${NC}"
            echo -e "    Run 'claude mcp list' to check server health"
        fi
    else
        echo -e "  ${YELLOW}⚠ Cannot verify OAuth - claude CLI not available${NC}"
        echo -e "    MCP server configured at: $mcp_url"
    fi
    echo ""
}

# Function: test_huggingface_cli_token
# Purpose: Tests the token-based authentication for the HuggingFace CLI.
test_huggingface_cli_token() {
    echo -e "${CYAN}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│${NC}$(center_text_in_box "${BLUE}HuggingFace CLI Token${NC}" 83)${CYAN}│${NC}"
    echo -e "${CYAN}└───────────────────────────────────────────────────────────────────────────────────┘${NC}"

    # Check if hf CLI is installed (modern command)
    if ! command -v hf &> /dev/null; then
        echo -e "  ${YELLOW}⚠ HuggingFace CLI not installed${NC}"
        echo -e "    Install with: pip install -U huggingface_hub[cli]"
        echo ""
        return
    fi

    # Try to get whoami info using the modern CLI command
    local hf_whoami_output=$(hf auth whoami 2>&1)
    local hf_exit=$?

    # Filter out deprecation warnings and strip ANSI color codes
    hf_whoami_output=$(echo "$hf_whoami_output" | grep -v "Warning:" | grep -v "deprecated" | sed 's/\x1b\[[0-9;]*m//g')

    # Parse the output
    if [ $hf_exit -eq 0 ]; then
        # The modern output is simpler: first line is username (may have "user: " prefix), then orgs if any
        local username=$(echo "$hf_whoami_output" | head -1 | sed 's/user: *//' | xargs)
        local orgs_line=$(echo "$hf_whoami_output" | grep "^orgs:" | sed 's/orgs: *//')

        if [ -n "$username" ] && [ "$username" != "" ]; then
            echo -e "  ${GREEN}✓ Token valid and authenticated${NC}"
            echo -e "    ${CYAN}Username:${NC} $username"

            # Show organizations if present
            if [ -n "$orgs_line" ]; then
                local org_count=$(echo "$orgs_line" | tr ',' '\n' | wc -l)
                echo -e "    ${CYAN}Organizations:${NC} $org_count ($orgs_line)"
            fi

            # Show token source if available
            if [ -n "$HF_TOKEN" ]; then
                echo -e "    ${CYAN}Token source:${NC} Environment variable (HF_TOKEN)"
            else
                echo -e "    ${CYAN}Token source:${NC} ~/.cache/huggingface/token"
            fi

            echo ""
            echo -e "  ${GREEN}Token can be used for:${NC}"
            echo -e "    ✓ hf CLI commands (model/dataset download, upload)"
            echo -e "    ✓ Python transformers/datasets libraries"
            echo -e "    ✓ Direct API access in scripts"
        else
            echo -e "  ${YELLOW}⚠ Unexpected output format${NC}"
            echo "$hf_whoami_output" | sed 's/^/    /'
        fi
    else
        # Authentication failed
        if echo "$hf_whoami_output" | grep -qi "not logged in"; then
            echo -e "  ${RED}✗ Not logged in to HuggingFace${NC}"
            echo ""
            echo -e "  ${CYAN}To fix - Option 1 (Recommended - Login via CLI):${NC}"
            echo -e "    1. Run: ${YELLOW}hf auth login${NC}"
            echo -e "    2. Paste your token when prompted"
            echo -e "    3. Token will be saved in ~/.cache/huggingface/token"
            echo ""
            echo -e "  ${CYAN}To fix - Option 2 (Environment Variable):${NC}"
            echo -e "    1. Go to: https://huggingface.co/settings/tokens"
            echo -e "    2. Create a new token with read permissions"
            echo -e "    3. Add to ~/.zshrc or ~/.profile:"
            echo -e "       ${YELLOW}export HF_TOKEN=\"hf_your_new_token\"${NC}"
            echo -e "    4. Run: ${YELLOW}source ~/.zshrc${NC}"
        elif echo "$hf_whoami_output" | grep -qi "invalid.*token"; then
            echo -e "  ${RED}✗ Invalid token${NC}"
            echo ""
            echo -e "  ${CYAN}To fix:${NC}"
            echo -e "    1. Go to: https://huggingface.co/settings/tokens"
            echo -e "    2. Create a new token with read permissions"
            echo -e "    3. Run: ${YELLOW}hf auth login${NC}"
            echo -e "    4. Or update HF_TOKEN in ~/.zshrc"
        else
            echo -e "  ${RED}✗ Authentication failed${NC}"
            echo -e "    Output: $hf_whoami_output"
        fi
    fi
    echo ""
}

# Function: test_context7_api
# Purpose: Tests the API key-based authentication for the Context7 API.
test_context7_api() {
    echo -e "${CYAN}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│${NC}$(center_text_in_box "${BLUE}Context7 API${NC}" 83)${CYAN}│${NC}"
    echo -e "${CYAN}└───────────────────────────────────────────────────────────────────────────────────┘${NC}"

    # Check if CONTEXT7_API_KEY is set
    if [ -z "$CONTEXT7_API_KEY" ]; then
        echo -e "  ${RED}✗ CONTEXT7_API_KEY environment variable not set${NC}"
        echo ""
        return 1
    fi

    # Test connection to Context7 SSE endpoint
    local http_code=$(curl -s -w "%{http_code}" -o /dev/null \
        -H "Accept: text/event-stream" \
        -H "CONTEXT7_API_KEY: $CONTEXT7_API_KEY" \
        "https://mcp.context7.com/mcp" \
        --max-time 5 2>/dev/null)

    if [ "$http_code" = "200" ]; then
        echo -e "  ${GREEN}✓ API key valid${NC}"
        echo -e "    ${CYAN}HTTP Status:${NC} 200 OK"
        echo -e "    ${CYAN}Connection:${NC} Successful"
    elif [ "$http_code" = "401" ] || [ "$http_code" = "403" ]; then
        echo -e "  ${RED}✗ Authentication failed${NC}"
        echo -e "    ${CYAN}HTTP Status:${NC} $http_code"
    elif [ -z "$http_code" ]; then
        echo -e "  ${YELLOW}⚠ Connection timeout or network error${NC}"
    else
        echo -e "  ${YELLOW}⚠ Unexpected response${NC}"
        echo -e "    ${CYAN}HTTP Status:${NC} $http_code"
    fi
    echo ""
}

# Function: test_api_keys
# Purpose: The main test function that dynamically tests the authentication status of all active servers in the current profile.
test_api_keys() {
    check_dependencies

    local project_path=$(get_project_path)
    local active_servers=$(get_active_servers)
    local server_count=$(count_active_servers)

    echo -e "${CYAN}=== MCP API Key Testing ===${NC}"
    echo ""
    echo -e "Project: ${CYAN}$project_path${NC}"
    echo -e "Active servers ($server_count): $active_servers"
    echo ""

    if [ "$server_count" -eq 0 ]; then
        echo -e "${YELLOW}No MCP servers configured${NC}"
        echo ""
        echo "Run 'mcp-profile dev' or another profile to configure servers"
        return
    fi

    echo -e "${BLUE}Testing CLI authentication and MCP servers...${NC}"
    echo ""

    # Track if we tested anything
    local tested=0

    # === CLI Tests First ===

    # Test GitHub CLI authentication
    if command -v gh &> /dev/null; then
        test_github_cli
        tested=$((tested + 1))
    fi

    # Test HuggingFace CLI token (test if CLI is available)
    if command -v hf &> /dev/null; then
        test_huggingface_cli_token
        tested=$((tested + 1))
    fi

    # === MCP Server Tests ===

    # Test GitHub MCP Server if active
    if echo "$active_servers" | grep -q "github"; then
        test_github_mcp_server
        tested=$((tested + 1))
    fi

    # Test HuggingFace MCP OAuth if active
    if echo "$active_servers" | grep -q "hf-mcp-server"; then
        test_huggingface_mcp_oauth
        tested=$((tested + 1))
    fi

    # Test Context7 API if active
    if echo "$active_servers" | grep -q "context7"; then
        test_context7_api
        tested=$((tested + 1))
    fi

    # If no servers requiring API keys were found
    if [ $tested -eq 0 ]; then
        echo -e "${CYAN}ℹ No servers requiring external API keys in current profile${NC}"
        echo ""
        echo "Servers like markitdown, playwright, shadcn, shadcn-ui"
        echo "don't require external API authentication."
        echo ""
    fi

    echo -e "${BLUE}Test Summary:${NC}"
    echo "  Profile servers tested: $tested"
    echo "  Servers not requiring API keys are working automatically"
    echo ""
}

# Function: check_profile_health
# Purpose: Checks the health of each server in a given profile.
# Arguments:
#   $1 - profile_name: The name of the profile to check.
# Returns: A space-separated string of status indicators ("ok", "warning", or "error") for each server in the profile.
check_profile_health() {
    local profile=$1
    local profile_file="$PROFILES_DIR/$profile.json"

    if [ ! -f "$profile_file" ]; then
        echo ""
        return
    fi

    local statuses=""

    # Read all servers from the profile
    local servers=$(jq -r 'keys[]' "$profile_file" 2>/dev/null)

    for server in $servers; do
        local server_status="ok"
        local server_type=$(jq -r --arg srv "$server" '.[$srv].type' "$profile_file" 2>/dev/null)

        if [ "$server_type" == "stdio" ]; then
            # Check if command exists
            local command=$(jq -r --arg srv "$server" '.[$srv].command' "$profile_file" 2>/dev/null)

            if [ -n "$command" ] && [ "$command" != "null" ]; then
                # Check if command is a full path
                if [[ "$command" == /* ]]; then
                    if [ ! -x "$command" ]; then
                        server_status="error"
                    fi
                else
                    # Check if command exists in PATH
                    if ! command -v "$command" &> /dev/null; then
                        server_status="warning"
                    fi
                fi
            fi
        elif [ "$server_type" == "http" ]; then
            # For HTTP servers, just verify URL format
            local url=$(jq -r --arg srv "$server" '.[$srv].url' "$profile_file" 2>/dev/null)
            if [ -z "$url" ] || [ "$url" == "null" ]; then
                server_status="warning"
            fi
        fi

        statuses="$statuses $server_status"
    done

    echo "$statuses" | xargs
}

# Function: get_visible_length
# Purpose: Calculates the visible length of a string by stripping out ANSI color codes.
# Arguments:
#   $1 - text: The string to measure.
# Returns: The visible length of the string.
get_visible_length() {
    local str="$1"
    # Remove ANSI escape sequences
    local visible=$(echo -e "$str" | sed 's/\x1b\[[0-9;]*m//g')
    echo "${#visible}"
}

# Function: center_text_in_box
# Purpose: Centers text within a specified width, accounting for ANSI color codes.
# Arguments:
#   $1 - text: The text to center (may include color codes).
#   $2 - width: The total width for the centered text.
center_text_in_box() {
    local text="$1"
    local width="$2"
    local visible_len=$(get_visible_length "$text")
    local total_padding=$((width - visible_len))
    local left_pad=$((total_padding / 2))
    local right_pad=$((total_padding - left_pad))
    printf "%*s%s%*s" "$left_pad" "" "$text" "$right_pad" ""
}

# Function: show_profile_table
# Purpose: Displays a formatted table of all available profiles, including their health status and which one is active.
show_profile_table() {
    local active_profile=$(identify_active_profile)

    echo -e "${BLUE}┌───────────────────────────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${BLUE}│${NC}$(center_text_in_box "${CYAN}Available Profiles${NC}" 83)${BLUE}│${NC}"
    echo -e "${BLUE}├──────────┬────────────────────────┬─────────┬──────────┬──────────────────────────┤${NC}"
    echo -e "${BLUE}│${NC} Profile  ${BLUE}│${NC} Description            ${BLUE}│${NC} Servers ${BLUE}│${NC} Tokens   ${BLUE}│${NC} Status                   ${BLUE}│${NC}"
    echo -e "${BLUE}├──────────┼────────────────────────┼─────────┼──────────┼──────────────────────────┤${NC}"

    for profile in github hf dev ui full; do
        IFS='|' read -r desc tokens <<< "${PROFILES[$profile]}"
        local server_count=$(jq 'length' "$PROFILES_DIR/$profile.json" 2>/dev/null || echo "0")

        # Get per-server health status
        local health_statuses=$(check_profile_health "$profile")

        # Build status display with individual server indicators
        local status_display=""

        for status in $health_statuses; do
            if [ "$status" == "ok" ]; then
                status_display="${status_display}${GREEN}✓${NC}"
            elif [ "$status" == "warning" ]; then
                status_display="${status_display}${YELLOW}⚠${NC}"
            else
                status_display="${status_display}${RED}✗${NC}"
            fi
        done

        # Add active marker if this is the active profile
        if [ "$active_profile" == "$profile" ]; then
            status_display="${status_display} ${CYAN}●${NC}"
        fi

        # Calculate visible length dynamically by stripping ANSI codes
        local visible_length=$(get_visible_length "$status_display")

        # Calculate padding needed for Status column content (24 chars)
        # Status column is: space(1) + content(24) + space(1) = 26 total
        local padding=$((24 - visible_length))
        local padding_str=$(printf '%*s' "$padding" '')

        # Determine token color - format with fixed width FIRST, then apply color
        local token_colored
        local token_padded=$(printf '%-8s' "$tokens")  # Pad to 8 chars
        if [[ "$tokens" == "~3K" ]] || [[ "$tokens" == "~7K" ]]; then
            token_colored="${GREEN}${token_padded}${NC}"
        elif [[ "$tokens" == "~12K" ]]; then
            token_colored="${YELLOW}${token_padded}${NC}"
        else
            token_colored="${RED}${token_padded}${NC}"
        fi

        # Print line with echo -e to properly render color codes
        echo -e "${BLUE}│${NC} $(printf '%-8s' "$profile") ${BLUE}│${NC} $(printf '%-22s' "$desc") ${BLUE}│${NC}   $(printf '%-5s' "$server_count") ${BLUE}│${NC} ${token_colored} ${BLUE}│${NC} ${status_display}${padding_str} ${BLUE}│${NC}"
    done

    echo -e "${BLUE}└──────────┴────────────────────────┴─────────┴──────────┴──────────────────────────┘${NC}"
    echo ""
    echo -e "${CYAN}Legend:${NC} ${GREEN}✓${NC} Ready  ${YELLOW}⚠${NC} Warning  ${RED}✗${NC} Error  ${CYAN}●${NC} Active"
    echo ""
}

# Function: verify_sync
# Purpose: Verifies that the configurations for Claude and Gemini are in sync with the currently active profile.
verify_sync() {
    check_dependencies
    local project_path=$(get_project_path)
    local active_profile=$(identify_active_profile)
    if [ "$active_profile" = "CUSTOM" ]; then
        echo -e "${YELLOW}Active profile is CUSTOM; cannot verify against a known profile${NC}"
        return 1
    fi
    local profile_file="$PROFILES_DIR/$active_profile.json"
    if [ ! -f "$profile_file" ]; then
        echo -e "${RED}Profile file not found: $profile_file${NC}"
        return 1
    fi
    echo -e "${BLUE}Verifying configs against profile: ${CYAN}$active_profile${NC}"
    # Claude check
    local claude_keys
    claude_keys=$(jq -r --arg path "$project_path" '(.projects[$path].mcpServers // {}) | keys | sort | join(",")' "$CLAUDE_CONFIG" 2>/dev/null || echo "")
    local profile_keys
    profile_keys=$(jq -r 'keys | sort | join(",")' "$profile_file" 2>/dev/null || echo "")
    if [ "$claude_keys" = "$profile_keys" ] && [ -n "$profile_keys" ]; then
        echo -e "  ${GREEN}\u2713 Claude matches profile (${active_profile})${NC}"
    else
        echo -e "  ${RED}\u2717 Claude mismatch${NC}"
        echo -e "    Claude:  $claude_keys"
        echo -e "    Profile: $profile_keys"
    fi
    # Gemini check (if available)
    if [ -f "$GEMINI_CONFIG" ]; then
        local gemini_keys
        gemini_keys=$(jq -r '(.mcpServers // {}) | keys | sort | join(",")' "$GEMINI_CONFIG" 2>/dev/null || echo "")
        if [ "$gemini_keys" = "$profile_keys" ] && [ -n "$profile_keys" ]; then
            echo -e "  ${GREEN}\u2713 Gemini matches profile (${active_profile})${NC}"
        else
            echo -e "  ${RED}\u2717 Gemini mismatch${NC}"
            echo -e "    Gemini:  $gemini_keys"
            echo -e "    Profile: $profile_keys"
        fi
    fi
}

# Function: interactive_menu
# Purpose: Displays an interactive menu for the user to manage their MCP profiles.
interactive_menu() {
    check_dependencies

    while true; do
        clear
        echo -e "${CYAN}=== MCP Profile Switcher ===${NC}"
        echo ""

        # Show current status
        local project_path=$(get_project_path)
        local active_profile=$(identify_active_profile)
        local server_count=$(count_active_servers)

        echo -e "Project: ${CYAN}$project_path${NC}"

        if [ "$active_profile" != "CUSTOM" ]; then
            IFS='|' read -r desc tokens <<< "${PROFILES[$active_profile]}"
            echo -e "Current profile: ${CYAN}${active_profile^^}${NC} ($desc, $tokens tokens)"
        else
            echo -e "Current profile: ${YELLOW}CUSTOM${NC} ($server_count servers)"
        fi

        echo ""
        show_profile_table
        echo "Select an action:"
        echo ""

        PS3=$'\n\033[0;34mEnter choice [1-9]: \033[0m'

        options=(
            "Switch to GITHUB profile (GitHub only, ~3K tokens)"
            "Switch to HF profile (HuggingFace only, ~73K tokens)"
            "Switch to DEV profile (Minimal, ~7K tokens)"
            "Switch to UI profile (Design work, ~12K tokens)"
            "Switch to FULL profile (All servers, ~12K tokens)"
            "Show detailed status"
            "Test API keys"
            "Show recent backups"
            "Quit"
        )

        select opt in "${options[@]}"; do
            case $REPLY in
                1)
                    echo ""
                    switch_profile "github"
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                2)
                    echo ""
                    switch_profile "hf"
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                3)
                    echo ""
                    switch_profile "dev"
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                4)
                    echo ""
                    switch_profile "ui"
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                5)
                    echo ""
                    switch_profile "full"
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                6)
                    echo ""
                    show_status
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                7)
                    echo ""
                    test_api_keys
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                8)
                    echo ""
                    show_backups
                    echo ""
                    read -p "Press Enter to continue..."
                    break
                    ;;
                9)
                    echo ""
                    echo -e "${GREEN}Goodbye!${NC}"
                    exit 0
                    ;;
                *)
                    echo -e "${RED}Invalid option. Please select 1-9.${NC}"
                    ;;
            esac
        done
    done
}

# Parse tool arguments first
parse_tool_arg "$@"

# Detect available tools
detect_tools


# Main script logic
case "${1:-interactive}" in
    github|hf|dev|ui|full)
        switch_profile "$1"
        ;;
    status)
        show_status
        ;;
    list)
        list_profiles
        ;;
    test)
        test_api_keys
        ;;
    verify)
        verify_sync
        ;;
    backup|backups)
        show_backups
        ;;
    help|--help|-h)
        echo -e "${CYAN}MCP Profile Switcher${NC}"
        echo ""
        echo "Manages MCP server profiles for Claude Code & Gemini CLI"
        echo ""
        echo "Commands:"
        echo "  github     - Switch to GitHub only profile"
        echo "  hf         - Switch to HuggingFace only profile"
        echo "  dev        - Switch to minimal development profile"
        echo "  ui         - Switch to UI work profile"
        echo "  full       - Switch to full profile (all servers)"
        echo "  status     - Show current active profile"
        echo "  list       - List all available profiles"
        echo "  test       - Test API keys for active MCP servers"
        echo "  verify     - Verify Claude & Gemini configs match active profile"
        echo "  backup     - Show recent backups"
        echo "  help       - Show this help message"
        echo "  (no args)  - Interactive menu (default)"
        echo ""
        echo "Options:"
        echo "  --tool=claude    - Manage only Claude Code"
        echo "  --tool=gemini    - Manage only Gemini CLI"
        echo "  --tool=copilot   - Manage only Copilot CLI (MCP unsupported; no-op)"
        echo "  --tool=all       - Manage all supported tools (default)"
        echo ""
        echo "Environment:"
        echo "  MCP_TOOL=<claude|gemini|all>  - Set default tool target"
        echo ""
        echo "Configuration:"
        echo "  Claude config:  $CLAUDE_CONFIG"
        echo "  Gemini config:  $GEMINI_CONFIG"
        echo "  Profiles dir:   $PROFILES_DIR"
        echo "  Claude backups: $CLAUDE_BACKUP_DIR"
        echo "  Gemini backups: $GEMINI_BACKUP_DIR"
        echo ""
        echo "Examples:"
        echo "  mcp-profile dev                    # Switch both tools to dev profile"
        echo "  mcp-profile full --tool=claude     # Switch only Claude Code to full"
        echo "  MCP_TOOL=gemini mcp-profile status # Check Gemini CLI status"
        echo ""
        echo "Note: Claude Code changes apply to current project: $(get_project_path)"
        echo "      Gemini CLI changes apply globally"
        echo "      Restart tools after switching profiles"
        ;;
    interactive|"")
        interactive_menu
        ;;
    *)
        # Ignore --tool flags when checking for unknown commands
        if [[ "$1" != --tool=* ]]; then
            echo -e "${RED}Unknown command: $1${NC}"
            echo ""
            list_profiles
            exit 1
        fi
        # If only --tool flag provided, show interactive menu
        interactive_menu
        ;;
esac
